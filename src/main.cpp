/*
 * File: main.cpp
 * Project: src
 * File Created: Thursday, 28th July 2022 5:15:25 pm
 * Author: Kwonilgun(Í∂åÏùºÍ∑º) (kwonilgun@naver.com)
 * -----
 * Last Modified: Monday, 3rd June 2024 1:52:49 pm
 * Modified By: Kwonilgun(Í∂åÏùºÍ∑º) (kwonilgun@naver.com>)
 * -----
 * Copyright <<projectCreationYear>> - 2024 Î£®Ìä∏Ïõê AI, Î£®Ìä∏Ïõê AI
 */


// Ï∞∏Ï°∞ ÏÇ¨Ïù¥Ìä∏ : https://github.com/toygame/aws-iot-device-provisioning-esp32/blob/main/src/main.cpp

#include <Arduino.h>
#include <SPIFFS.h>
#include <WiFi.h>
#include <ArduinoJson.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <Preferences.h>
#include "config.h"
#include "serial_communication.h"
#include "main.h"
#include "util.h"

//2024-06-08 :  wifi manager Ï∂îÍ∞Ä
#include <WiFiManager.h> // https://github.com/tzapu/WiFiManager

#include "async.h"

//2024-06-16 : Async WebServer Ï∂îÍ∞Ä
#include <ESPAsyncWebServer.h>
#include <AsyncTCP.h>
// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

#define DEBUG

// EPS32 serial port  Ï∞∏Ï°∞ ÏÇ¨Ïù¥Ìä∏ : https://circuits4you.com/2018/12/31/esp32-hardware-serial2-example/
/*
 * There are three serial ports on the ESP known as U0UXD, U1UXD and U2UXD.
 * 
 * U0UXD is used to communicate with the ESP32 for programming and during reset/boot.
 * U1UXD is unused and can be used for your projects. Some boards use this port for SPI Flash access though
 * U2UXD is unused and can be used for your projects.
 * 
*/

#define RXD2 16
#define TXD2 17

WiFiClientSecure net;
PubSubClient client(net);

Preferences preferences;

int init_count = 0;
unsigned long start_time;
unsigned long end_time;

// // port(5,6) ozs serial ÌÜµÏã†
// SoftwareSerial SerialPort(D5,D6);

String receivedString = ""; // ÏàòÏã†Îêú Î¨∏ÏûêÏó¥ÏùÑ Ï†ÄÏû•Ìï† Î≥ÄÏàò
bool insideBrackets = false; // '['ÏôÄ ']' ÏÇ¨Ïù¥Ïùò Î¨∏ÏûêÏó¥Ïù∏ÏßÄ Ïó¨Î∂ÄÎ•º ÎÇòÌÉÄÎÇ¥Îäî ÌîåÎûòÍ∑∏


//2024-06-16 : Async server parameters......
// Search for parameter in HTTP POST request
const char* PARAM_INPUT_1 = "ssid";
const char* PARAM_INPUT_2 = "pass";
const char* PARAM_INPUT_3 = "ip";
const char* PARAM_INPUT_4 = "gateway";

//Variables to save values from HTML form
String ssid;
String pass;
String ip;
String gateway;
// File paths to save input values permanently
const char* ssidPath = "/ssid.txt";
const char* passPath = "/pass.txt";
const char* ipPath = "/ip.txt";
const char* gatewayPath = "/gateway.txt";

IPAddress localIP;
//IPAddress localIP(192, 168, 1, 200); // hardcoded

// Set your Gateway IP address
IPAddress localGateway;
//IPAddress localGateway(192, 168, 1, 1); //hardcoded
IPAddress subnet(255, 255, 0, 0);

// Timer variables
unsigned long previousMillis = 0;
const long interval = 5000;  // interval to wait for Wi-Fi connection (milliseconds)

String loop_start = "NO_OP"; 

// 2024-06-18 : wifi ÏÑ∏ÌåÖÏù¥ Ï†úÎåÄÎ°ú ÎêòÏóàÎäî ÏßÄ ÌôïÏù∏ÌïòÎäî status 
// bool wifiConnectionSuccess = false;


void initializeAwsJson()
{
  // Write invalid JSON content to the file
  const char* invalidJsonContent = "This is not valid JSON!";
  
  // Open the file for writing
  File file = SPIFFS.open("/aws.json", "w");
  if (!file)
  {
    Serial.println("Failed to open file for writing");
    return;
  }

  // Write the invalid JSON content to the file
  file.print(invalidJsonContent);
  
  // Close the file
  file.close();
  
  Serial.println("AWS JSON file initialized with invalid JSON content");
}

void saveCertificateToFS(DynamicJsonDocument doc)
{

  // client.publish("$aws/certificates/create/json", "") ÏóêÏÑú certificate ÏÉùÏÑ±Ïù¥ ÏöîÏ≤≠, 
  DynamicJsonDocument pem(4000);
  pem["certificatePem"] = doc["certificatePem"];
  pem["privateKey"] = doc["privateKey"];
  File file = SPIFFS.open("/aws.json", "w");
  if (!file)
  {
    Serial.println("failed to open config file for writing");
  }
  serializeJson(pem, Serial);
  serializeJson(pem, file);
  file.close();
}

void registerThing(DynamicJsonDocument doc)
{
  Serial.println("registerThing....... ");
  const char *certificateOwnershipToken = doc["certificateOwnershipToken"];
  DynamicJsonDocument reqBody(4000);
  reqBody["certificateOwnershipToken"] = certificateOwnershipToken;
  reqBody["parameters"]["SerialNumber"] = WiFi.macAddress();
  char jsonBuffer[4000];
  serializeJson(reqBody, jsonBuffer);
  Serial.println(">>>>>>>>>>>>>Sending certificate<<<<<<<<<<<");
  client.publish("$aws/provisioning-templates/claim_0603/provision/json", jsonBuffer);
}

void messageHandler(String topic, byte *payload, int length)
{

  start_time = millis();

  Serial.print("incoming: ");
  Serial.println(topic);
  // DynamicJsonDocument doc(length);
  DynamicJsonDocument doc(1000);

  //2024-06-03 : payloadÏóê provisionÏóêÏÑú Î∞úÌñâÎêú Ïù∏Ï¶ùÏÑúÍ∞Ä Ïã§Î†§ Ïò®Îã§. Ïù¥Í≤ÉÏùÑ /aws.json ÌååÏùºÏóê Ï†ÄÏû•ÏùÑ ÌïòÍ≥† , Ï†ÄÏû•Îêú ÌååÏùºÏùÑ Ïù¥Ïö©Ìï¥ÏÑú iot Í¥ÄÎ†® ÏÑúÎπÑÏä§Î•º ÏßÑÌñâÌïòÎ©¥ ÎêúÎã§. Î®ºÏ†Ä $aws/certificates/create/json/accepted, Î∞õÏïÑÏÑú Ïã§ÌñâÏùÑÌïòÍ≥†, registerThingsÏóêÏÑú $aws/provisioning-templates/claim_0603/provision/jsonÎ•º publish ÌïòÎ©¥ Î∞õÏïÑÏÑú restart ÌïòÍ≤å ÎêúÎã§.  

  String subscriptionTopic = String(AWS_IOT_SUB_TOPIC) + WiFi.macAddress();
  char subTopic[100];
  subscriptionTopic.toCharArray(subTopic, 100);

  deserializeJson(doc, payload);

  String output;
  serializeJsonPretty(doc, output);
  // Serial.print("messageHandler Received JSON: ");
  // Serial.println(output);

  if (topic == "$aws/certificates/create/json/accepted")
  {
    saveCertificateToFS(doc);
    registerThing(doc);
  }
  else if (topic == "$aws/provisioning-templates/claim_0603/provision/json/accepted")
  {
    Serial.println("Register things successfully.");
    Serial.println("Restart in 5s.");
    sleep(5);
    ESP.restart();
  }
  else if(topic == subTopic){
    Serial.print("messageHandler: match subscription topic =");
    Serial.println(subTopic);
    on_message_received(topic, doc , length);
  }
}

void connectToAWS(DynamicJsonDocument cert)
{
  net.setCACert(AWS_CERT_CA);
  net.setCertificate(cert["certificatePem"]);
  net.setPrivateKey(cert["privateKey"]);
  client.setServer(AWS_IOT_ENDPOINT, 8883);
  // Create a message handler
  client.setCallback(messageHandler);

  //üíá‚Äç‚ôÄÔ∏èüßö‚Äç‚ôÄÔ∏è 2024-06-04 Sets the keep alive interval used by the client. This value should only be changed when the client is not connected. Ïù¥Í≤ÉÏùÑ Ïù¥Ïö©Ìï¥ÏÑú keep alive ÏãúÍ∞ÑÏùÑ Ï°∞Ï†ïÌï† Ïàò ÏûàÎã§. Í≥ÑÏÜçÌï¥ÏÑú c0 00 ÏùÑ Î≥¥ÎÇ∏Îã§. 
  // /Users/kwon/.platformio/packages/framework-arduinoespressif32/libraries/WiFiClientSecure/src/ssl_client.cpp ÏóêÏÑú  send_ssl_data(sslclient_context *ssl_client, const uint8_t *data, size_t len), Îç∞Ïù¥ÌÑ∞Î•º Í≥ÑÏÜçÌï¥ÏÑú Î≥¥ÎÇ∏Îã§.

  // Ï∞∏Ï°∞ ÏÇ¨Ïù¥Ìä∏: PubSubClient API : https://pubsubclient.knolleary.net/api#setKeepAlive


  //2024-06-05 : 5Î∂ÑÏóê ÌïúÎ≤àÏî© PINGREQÎ•º Î≥¥ÎÇ∏Îã§.  
  client.setKeepAlive(30 * 10);

  
  
  if(client.setBufferSize(4000)){
    Serial.println("buffer resized");
  }
  else{
    Serial.println("buffer could not be resized");
  }
  Serial.print("Connecting to AWS IOT.");

  String clientId = "ESP32_" + WiFi.macAddress(); // Í≥†Ïú†Ìïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID ÏÉùÏÑ±
  unsigned long startAttemptTime = millis();
  const unsigned long timeout = 5000;  // 5Ï¥à ÎèôÏïà ÏãúÎèÑ
  
  // Ïó∞Í≤∞ ÏãúÎèÑ
  while (!client.connected() && millis() - startAttemptTime < timeout) {
    Serial.print(".");
    if (client.connect(clientId.c_str())) { // ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ: client.connect()Î•º if Î¨∏ÏúºÎ°ú Í∞êÏã∏ÏÑú Ïó∞Í≤∞ ÏÑ±Í≥µ Ïó¨Î∂Ä ÌôïÏù∏
      Serial.println("Connected");
      Serial.print("MQTT state: ");
      Serial.println(client.state());  // MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉÅÌÉú Ï∂úÎ†•
      delay(100);
    }
  }

  if (!client.connected()) {
    Serial.println("Timeout!");
    // Ïó¨Í∏∞Ïóê Ï†ÅÏ†àÌïú Ïò§Î•ò Ï≤òÎ¶¨ ÏΩîÎìú Ï∂îÍ∞Ä (Ïòà: Ïò§Î•ò Î©îÏãúÏßÄ Ï∂úÎ†•, Ïû¨ÏãúÎèÑ, ÏãúÏä§ÌÖú Ïû¨ÏãúÏûë Îì±)
    // ESP.restart();
  }

  // delay(1000);

  // topic Ìï©ÏÑ± : ozs/client8266/ + mac Ï£ºÏÜå
  String subscriptionTopic = String(AWS_IOT_SUB_TOPIC) + WiFi.macAddress();
  char topic[100];
  subscriptionTopic.toCharArray(topic, 100);
  Serial.printf("Subscription topic: %s", topic);
  Serial.println();
  client.subscribe(topic);
  

  // delay(2000);

  // 2024-06-04 : send wifi ready
  send_wifi_ready();

  
}

void publish_ozs_status(String &message){

  #ifdef DEBUG
  Serial.println("report ozs board status......." + message);
  #endif

  // ":" delimiterÎ°ú messageÎ•º Î∂ÑÎ¶¨
  int delimiterIndex = message.indexOf(':');
  String firstToken = message.substring(0, delimiterIndex);
  firstToken.trim();

  // Serial.println("firstToke = " + firstToken);
  String secondToken = message.substring(delimiterIndex + 1);

  delimiterIndex = secondToken.indexOf(':');
  String status = secondToken.substring(0,delimiterIndex);
  String time = secondToken.substring(delimiterIndex+1);
  
  #ifdef DEBUG
  Serial.println("status = " + status);
  Serial.println("time = " + time);
  #endif


  StaticJsonDocument<200> doc;

  doc["status"] = status;
  doc["time"] = time;

  char publishBuffer[512];
  serializeJson(doc, publishBuffer); // print to client


// topic Ìï©ÏÑ± : ozs/client8266/ + mac Ï£ºÏÜå
  String publishTopic = String(AWS_IOT_PUB_TOPIC) + WiFi.macAddress();
  char pubTopic[100];
  publishTopic.toCharArray(pubTopic, 100);
  Serial.printf("publish topic: %s", pubTopic);
  Serial.println();

//2024-06-05 : client.publish(pubTopic, publishBuffer, 0), the third parameter 0 specifies that the message should be delivered with QoS 0 (at most once).
  if (client.publish(pubTopic, publishBuffer))
  {
    Serial.printf("Publish to topic %s successful\n", pubTopic);
    Serial.println();
  }
  else
  {
    Serial.printf("Publish to topic %s failed\n", pubTopic);
    Serial.println();
  }


  end_time = millis();

  unsigned long elapsedTime = end_time - start_time;
  Serial.print("\n Message handling and publishing took: ");
  Serial.print(elapsedTime);
  Serial.println(" ms");


}

void publish_ozs_system_info(String &message){
  
  // Serial.println("report ozs system info = " + message);

  // ":" delimiterÎ°ú messageÎ•º Î∂ÑÎ¶¨
  int delimiterIndex = message.indexOf(':');
  String firstToken = message.substring(0, delimiterIndex);

#ifdef DEBUG
  // Serial.println("firstToke = " + firstToken);
#endif
  String info = message.substring(delimiterIndex + 1);


  
  Serial.println("publish_ozs_system_info  info = " + info);

  String clientId = "" + WiFi.macAddress();
  
  StaticJsonDocument<200> doc;

  doc["info"] = info;
  doc["serial"] = clientId;
  // 2024-06-10 : esp32 software version
  doc["esp"] = GetIniString("software", "version", "0");
  
  // Data Ìï©ÏÑ±
  char publishData[512];
  serializeJson(doc, publishData); // print to client

  // topic Ìï©ÏÑ± : ozs/client8266/ + mac Ï£ºÏÜå
  String publishTopic = String(AWS_IOT_PUB_TOPIC) + WiFi.macAddress();
  char pubTopic[100];
  publishTopic.toCharArray(pubTopic, 100);
  Serial.printf("publish topic: %s", pubTopic);
  Serial.println();

  // client.publish(pubTopic, publishData, 0);

  //2024-06-05 : client.publish(pubTopic, publishBuffer, 0), the third parameter 0 specifies that the message should be delivered with QoS 0 (at most once).
  if (client.publish(pubTopic, publishData))
  {
    Serial.printf("Publish to topic %s successful\n", pubTopic);
  }
  else
  {
    Serial.printf("Publish to topic %s failed\n", pubTopic);
  }

  end_time = millis();

  unsigned long elapsedTime = end_time - start_time;
  Serial.print("\nMessage handling and publishing took: ");
  Serial.print(elapsedTime);
  Serial.println(" ms");

}

// 2024-06-19 : esp32 Ïó∞Í≤∞ Ï≤¥ÌÅ¨
void publishMessageConnection(){
  
  Serial.println("publishMessageConnection ....");

  String clientId = "" + WiFi.macAddress();
  
  StaticJsonDocument<200> doc;

  doc["connect"] = "success";
  doc["mac"] = clientId;
  
  // Data Ìï©ÏÑ±
  char publishData[512];
  serializeJson(doc, publishData); // print to client

  // topic Ìï©ÏÑ± : ozs/client8266/ + mac Ï£ºÏÜå
  String publishTopic = String(AWS_IOT_PUB_TOPIC) + WiFi.macAddress();
  char pubTopic[100];
  publishTopic.toCharArray(pubTopic, 100);
  Serial.printf("publish connection topic: %s \r\n", pubTopic);
  

  //2024-06-05 : client.publish(pubTopic, publishBuffer, 0), the third parameter 0 specifies that the message should be delivered with QoS 0 (at most once).
  if (client.publish(pubTopic, publishData))
  {
    Serial.printf("Publish to topic %s successful\n", pubTopic);
  }
  else
  {
    Serial.printf("Publish to topic %s failed\n", pubTopic);
  }

  // end_time = millis();

  // unsigned long elapsedTime = end_time - start_time;
  // Serial.print("\nMessage handling and publishing took: ");
  // Serial.print(elapsedTime);
  // Serial.println("ms");
}

void createCertificate()
{
  Serial.println("No file content.");

  //2024-06-03 : Provisioning devices with claim certificates, --> Connect / connect many devicesÏóê ÏûàÎäî Provisioned devices with claim certificatesÎ•º ÏÑ†ÌÉùÌïòÍ≥† iam, policy, Ïù∏Ï¶ùÏÑúÎ•º ÏÑ†ÌÉùÌïúÎã§. Ïù∏Ï¶ùÏÑúÎäî Security/Certificates ÏóêÏÑú ÏÉùÏÑ±ÏùÑ ÌïòÍ≥†, device certificate, private keyÎ•º Ïó¨Í∏∞ÏÑú Îã§Ïö¥Î°úÎìú Î∞õÎäîÎã§. 

  // Choose this option if your IoT devices are delivered with claim certificates that are shared with other devices. The devices use their claim certificates to connect to AWS IoT for the first time. The claim certificate is replaced with a unique device certificate after provisioning. This option is also known as fleet provisioning with certificate.


  net.setCACert(AWS_CERT_CA);
  net.setCertificate(AWS_CERT_CRT);
  net.setPrivateKey(AWS_CERT_PRIVATE);
  client.setServer(AWS_IOT_ENDPOINT, 8883);
  // Create a message handler
  client.setCallback(messageHandler);
  // Set buffer size for receive a certificate.
  client.setBufferSize(4000);
  Serial.println("Connecting to AWS IOT.");
  String clientId = "ESP32_" + WiFi.macAddress(); // Í≥†Ïú†Ìïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID ÏÉùÏÑ±
  Serial.println("clientId ");
  Serial.println(clientId);
  while (!client.connect(clientId.c_str())) {
    Serial.print(".");
    delay(1000);
  }
  Serial.println("Connected");
  client.subscribe("$aws/certificates/create/json/accepted");
  client.subscribe("$aws/certificates/create/json/rejected");

  //2024-06-03 : üíá‚Äç‚ôÄÔ∏èüíá‚Äç‚ôÄÔ∏è, ÌïµÏã¨ÏùÄ claim_0603 Ïù¥Îã§. Ïù¥Í≤ÉÏù¥ Provisioning devices with claim certificates ÏóêÏÑú ÏÉùÏÑ±Ìïú template Ïù¥Î¶ÑÏù¥Îã§. Ïù¥ Ïù¥Î¶ÑÏùÑ ÏßÄÏ†ïÌï¥ÏïºÎßå Ï†úÎåÄÎ°ú ÏûëÎèôÏù¥ ÎêúÎã§. ÏïÑÎãàÎ©¥ reject Ïù¥ ÎêúÎã§. 
  client.subscribe("$aws/provisioning-templates/claim_0603/provision/json/accepted");
  client.subscribe("$aws/provisioning-templates/claim_0603/provision/json/rejected");
  Serial.println("Create certificate..");

  /*
  client.publish("$aws/certificates/create/json", "")Ïùò Ïó≠Ìï†
Î™©Ï†Å: client.publish("$aws/certificates/create/json", "")Ïùò Î™©Ï†ÅÏùÄ AWS IoT CoreÏóê Ïû•ÏπòÏùò ÏÉàÎ°úÏö¥ Ïù∏Ï¶ùÏÑúÎ•º ÏÉùÏÑ±ÌïòÎùºÎäî ÏöîÏ≤≠ÏùÑ Î≥¥ÎÇ¥Îäî Í≤ÉÏûÖÎãàÎã§. $aws/certificates/create/json ÌÜ†ÌîΩÏùÄ Ïù¥ ÌÜ†ÌîΩÏóê Î©îÏãúÏßÄÍ∞Ä Î∞úÌñâÎêòÎ©¥ AWS IoT CoreÍ∞Ä ÏÉàÎ°úÏö¥ Ïù∏Ï¶ùÏÑúÎ•º ÏÉùÏÑ±ÌïòÎäî ÌäπÎ≥ÑÌïú ÌÜ†ÌîΩÏûÖÎãàÎã§.

Î©îÏª§ÎãàÏ¶ò:

AWS IoT CoreÍ∞Ä Ïù¥ ÌÜ†ÌîΩÏóêÏÑú Î∞úÌñâ ÏöîÏ≤≠ÏùÑ ÏàòÏã†ÌïòÎ©¥, ÏöîÏ≤≠ÏùÑ Ï≤òÎ¶¨ÌïòÍ≥† Ïû•ÏπòÏóê ÎåÄÌïú ÏÉàÎ°úÏö¥ Ïù∏Ï¶ùÏÑúÎ•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
Í∑∏Îü∞ Îã§Ïùå AWS IoT CoreÎäî $aws/certificates/create/json/accepted (ÏÑ±Í≥µ Ïãú) ÎòêÎäî $aws/certificates/create/json/rejected (Ïò§Î•ò Î∞úÏÉù Ïãú) ÌÜ†ÌîΩÏóê Î©îÏãúÏßÄÎ°ú ÏùëÎãµÌï©ÎãàÎã§.
ÏùëÎãµ Ï≤òÎ¶¨:

messageHandler Ìï®ÏàòÍ∞Ä AWS IoT CoreÏùò ÏùëÎãµÏùÑ Ï≤òÎ¶¨Ìï©ÎãàÎã§.
ÏùëÎãµ ÌÜ†ÌîΩÏù¥ $aws/certificates/create/json/acceptedÏù∏ Í≤ΩÏö∞, saveCertificateToFS(doc)Î•º Ìò∏Ï∂úÌïòÏó¨ ÏàòÏã†Îêú Ïù∏Ï¶ùÏÑúÏôÄ Í∞úÏù∏ ÌÇ§Î•º SPIFFS ÌååÏùº ÏãúÏä§ÌÖúÏóê Ï†ÄÏû•ÌïòÍ≥† registerThing(doc)ÏùÑ Ìò∏Ï∂úÌïòÏó¨ Ïû•ÏπòÎ•º Îì±Î°ùÌï©ÎãàÎã§.
ÏùëÎãµ ÌÜ†ÌîΩÏù¥ $aws/certificates/create/json/rejectedÏù∏ Í≤ΩÏö∞, ÌïÑÏöîÌïú Ïò§Î•ò Ï≤òÎ¶¨Î•º Íµ¨ÌòÑÌï† Ïàò ÏûàÏäµÎãàÎã§.
Ïù¥ ÌÜ†ÌîΩÏóê Î∞úÌñâÌï®ÏúºÎ°úÏç®, Ìï®ÏàòÎäî AWS IoTÎ°úÎ∂ÄÌÑ∞ ÏÉàÎ°úÏö¥ Ïù∏Ï¶ùÏÑúÎ•º ÏñªÎäî Í≥ºÏ†ïÏùÑ ÏãúÏûëÌïòÎ©∞, Ïù¥Îäî IoT ÌôòÍ≤ΩÏóêÏÑú ÏïàÏ†ÑÌïú ÌÜµÏã†Í≥º Ïù∏Ï¶ùÏùÑ ÏúÑÌï¥ Îß§Ïö∞ Ï§ëÏöîÌï©ÎãàÎã§.
  */
  client.publish("$aws/certificates/create/json", "");
}


void reconnect() {
  // Ïó∞Í≤∞ ÏãúÎèÑ Î∞è Ïã§Ìå® Ïãú Ïû¨ÏãúÎèÑ
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID ÏÑ§Ï†ï
    String clientId = "ESP32_" + WiFi.macAddress(); // Í≥†Ïú†Ìïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ID ÏÉùÏÑ±
    // clientId += String(random(0xffff), HEX);
    // // MQTT Î∏åÎ°úÏª§Ïóê Ïó∞Í≤∞ ÏãúÎèÑ
    if (client.connect(clientId.c_str())) {
      Serial.println("reconnected");
      // topic Ìï©ÏÑ± : ozs/client8266/ + mac Ï£ºÏÜå
        String subscriptionTopic = String(AWS_IOT_SUB_TOPIC) + WiFi.macAddress();
        char topic[100];
        subscriptionTopic.toCharArray(topic, 100);
        Serial.printf("reSubscription topic: %s", topic);
        Serial.println();
        client.subscribe(topic);

        // 2024-06-04 : send wifi ready
        send_wifi_ready();

    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}


// Initialize WiFi
bool initWiFi(String cont) {
  // if(ssid=="" || ip==""){
  if((ssid=="") || (cont == "init_ap")){
    Serial.println("Undefined SSID or IP address.");
    return false;
  }

  WiFi.mode(WIFI_STA);
  // localIP.fromString(ip.c_str());
  // localGateway.fromString(gateway.c_str());


  // if (!WiFi.config(localIP, localGateway, subnet)){
  //   Serial.println("STA Failed to configure");
  //   return false;
  // }

  // 2024-06-16 : ssid, password setting 
  WiFi.begin(ssid.c_str(), pass.c_str());
  // WiFi.begin(ssid.c_str(), );
  Serial.println("Connecting to WiFi...");

  unsigned long currentMillis = millis();
  previousMillis = currentMillis;

  while(WiFi.status() != WL_CONNECTED) {
    currentMillis = millis();
    if (currentMillis - previousMillis >= interval) {
      Serial.println("Failed to connect.");
      return false;
    }
  }

  Serial.println("WiFi succeed to connect");
  Serial.println(WiFi.localIP());

  //  wifiConnectionSuccess = true; // Set flag to true on success
  
  return true;
}

void gotoSoftApSetup() {
        // Connect to Wi-Fi network with SSID and password
    Serial.println("Setting AP (Access Point)");
    // NULL sets an open Access Point
    WiFi.softAP("ROOTONE-AI-AP", "ROOTONE-AI-PWD");

    IPAddress IP = WiFi.softAPIP();
    Serial.print("AP IP address: ");
    Serial.println(IP); 

    // Web Server Root URL
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
      Serial.println("http_get /....");

      request->send(200, "text/plain", "Wifi manager connection success");

      // request->send(SPIFFS, "/wifimanager.html", "text/html");
    });

    server.on("/mac", HTTP_GET, [](AsyncWebServerRequest *request){
      Serial.println("http_get /mac ....");
      String mac = WiFi.macAddress();
      request->send(200, "text/plain", mac);
      
    });

    // wifi connectionÏù¥ ÏÑ±Í≥µÌñàÎäîÏßÄ Ïã§Ìå®ÌñàÎäî ÏßÄ ÌôïÏù∏.
    server.on("/status", HTTP_GET, [](AsyncWebServerRequest *request) {

      Serial.println("http_get /status rx....");
      
    // if (wifiConnectionSuccess) {
    //   request->send(200, "text/plain", "Connected to WiFi successfully.");
    // } else {
    //   request->send(400, "text/plain", "Failed to connect to WiFi. Please check SSID and password.");
    // }
  });
    
    server.serveStatic("/", SPIFFS, "/");
    
    server.on("/", HTTP_POST, [](AsyncWebServerRequest *request) {

      Serial.println("http post rx");

      int params = request->params();
      
      Serial.printf("http post rx params = %d \n", params);

      for(int i=0;i<params;i++){
        AsyncWebParameter* p = request->getParam(i);
         // ÏÇºÌï≠ Ïó∞ÏÇ∞ÏûêÎ•º ÏÇ¨Ïö©ÌïòÏó¨ bool Í∞íÏùÑ "true" ÎòêÎäî "false" Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
        Serial.printf("The value of myBool is: %s\n", p->isPost() ? "true" : "false");

        Serial.printf(" p-> name = %s \n", p->name());

        if(p->isPost()){
          // HTTP POST ssid value
          if (p->name() == PARAM_INPUT_1) {
            ssid = p->value().c_str();
            Serial.print("SSID set to: ");
            Serial.println(ssid);
            // Write file to save value
            writeFile(SPIFFS, ssidPath, ssid.c_str());
          }
          // HTTP POST pass value
          if (p->name() == PARAM_INPUT_2) {
            pass = p->value().c_str();
            Serial.print("Password set to: ");
            Serial.println(pass);
            // Write file to save value
            writeFile(SPIFFS, passPath, pass.c_str());
          }
          // HTTP POST ip value
          if (p->name() == PARAM_INPUT_3) {
            ip = p->value().c_str();
            Serial.print("IP Address set to: ");
            Serial.println(ip);
            // Write file to save value
            writeFile(SPIFFS, ipPath, ip.c_str());
          }
          // HTTP POST gateway value
          if (p->name() == PARAM_INPUT_4) {
            gateway = p->value().c_str();
            Serial.print("Gateway set to: ");
            Serial.println(gateway);
            // Write file to save value
            writeFile(SPIFFS, gatewayPath, gateway.c_str());
          }
          //Serial.printf("POST[%s]: %s\n", p->name().c_str(), p->value().c_str());
        }
      }
      request->send(200, "text/plain", "Done. ESP will restart, connect to your router and go to IP address: " + ip);
      
      
      delay(2000);

      SetIniString("softap", "ssid", "operate");

      // wifiConnectionSuccess = false; // Set flag to false on failure
      // delay(10000); // Add a delay to ensure the HTTP response can be sent before restart, 10Ï¥àÎ•º Í∏∞Îã§Î¶∞Îã§. 

      ESP.restart();
    });
    server.begin();
}

void setup()
{
  Serial.begin(115200);

  // Note the format for setting a serial port is as follows: Serial2.begin(baud-rate, protocol, RX pin, TX pin);
 
  Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2);

  initSPIFFS();

  // WiFi.mode(WIFI_STA);
  // WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi..");

  Serial.println("start setup..");

  String check_ssid =  GetIniString("softap", "ssid", "init_ap");
  Serial.println(check_ssid);

   // Load values saved in SPIFFS
  ssid = readFile(SPIFFS, ssidPath);
  pass = readFile(SPIFFS, passPath);
  ip = readFile(SPIFFS, ipPath);
  gateway = readFile (SPIFFS, gatewayPath);
  Serial.println(ssid);
  Serial.println(pass);
  Serial.println(ip);
  Serial.println(gateway);

  // Attempt to connect to WiFi
  // WiFiManager wm;

  if (check_ssid == "init_ap") {
    // No stored SSID, start WiFiManager
    Serial.println("check_ssid is init_ap ....");
    loop_start = "NO";
    send_setup_voice_stm();     //ÏùåÏÑ±ÏúºÎ°ú softAp ÏãúÏûëÏùÑ ÏïåÎ†§Ï§ÄÎã§. 
    gotoSoftApSetup();

  } 
  else if(ssid == ""){
    Serial.println(" ssid is empty  ....");
    loop_start = "NO";
    gotoSoftApSetup();
  }
  else {
    if(initWiFi("operate")){
          // Route for root / web page
              Serial.println("initWiFi OK");
              loop_start = "YES_OP";
              
              Serial.println("Connected.");

              // Read AWS config file.
              File file = SPIFFS.open("/aws.json", "r");
              if (!file)
              {
                Serial.println("Failed to open file for reading");
                return;
              }

              Serial.println("\nsucceed to open file for reading..");

              // delay(1000);

              DynamicJsonDocument cert(4000);
              auto deserializeError = deserializeJson(cert, file);

              if (!deserializeError)
              {
                  Serial.println("deserializeError false");
                  if (cert["certificatePem"])
                  {
                    connectToAWS(cert);
                  }
              }
              else 
              {
                //2024-06-03 : ÏµúÏ¥àÎäî Ïó¨Í∏∞Î°ú Ïò®Îã§. ÏóêÎü¨Î•º ÏùºÎ∂ÄÎü¨ Î∞úÏÉùÌïúÎã§. 
                  Serial.println("start createCertificate....");
                  createCertificate();
              }
              file.close();

      }
      else{

          Serial.println("***********");
          Serial.println(" !!!!!!!connection fail and restart ESP!!!!!!");
          Serial.println("***********");

          // 2024-06-18 : üíá‚Äç‚ôÄÔ∏è !!!!!!! 10Ï¥à ÎèôÏïà ÏôÄÏù¥ÌååÏù¥Î•º Ïó∞Í≤∞ÌñàÏßÄÎßå ÏïàÎê®. Îã§Ïãú Ï≤òÏùå Î∂ÄÌÑ∞ ÏãúÏûëÏúº Ìï¥ÏïºÌïúÎã§. 
          deleteAllFiles();

          SetIniString("softap", "ssid", "init_ap");


          // wifiConnectionSuccess = false; // Set flag to false on failure
          delay(2000); // Add a delay to ensure the HTTP response can be sent before restart

        
          ESP.restart();
      
      }
  }

}

void deleteFile(fs::FS &fs, const char * path) {
  Serial.printf("Deleting file: %s\n", path);

  // ÌååÏùº ÏÇ≠Ï†ú ÏãúÎèÑ
  if (fs.remove(path)) {
    Serial.println("File deleted successfully");
  } else {
    Serial.println("Failed to delete file");
  }
}

void deleteAllFiles(){

  // // ÌååÏùº Í≤ΩÎ°ú
  // const char* filePath = "/aws.json";

  // // ÌååÏùº ÏÇ≠Ï†ú ÏãúÎèÑ
  // if (SPIFFS.remove(filePath)) {
  //   Serial.println("AWS JSON file deleted successfully");
  // } else {
  //   Serial.println("Failed to delete AWS JSON file");
  // }

  // ÌååÏùº ÏÇ≠Ï†ú Ìï®Ïàò Ìò∏Ï∂ú
  deleteFile(SPIFFS, ssidPath);
  deleteFile(SPIFFS, passPath);
  deleteFile(SPIFFS, ipPath);
  deleteFile(SPIFFS, gatewayPath);
}



void loop()
{


  if(loop_start == "YES_OP"){

        if (!client.connected()) {
            Serial.println("\n\n>>>>>>>>>>client connected error occurs..Restart.<<<<<<<<<<<<<\n\n");
            ESP.restart();
            return;
        }
        client.loop();

        // server.handleClient(); // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏöîÏ≤≠ Ï≤òÎ¶¨


        // 2024-06-04 computer terminalÎ°ú Îì§Ïñ¥Ïò® Serial Î™ÖÎ†π Ï≤òÎ¶¨
        if (Serial.available()) {
          String command = Serial.readStringUntil('\n');
          command.trim();  // Í≥µÎ∞± Ï†úÍ±∞


          // Check if the command starts with "write serial#"
          if (command.startsWith("write version:")) {
            // ":" delimiterÎ°ú messageÎ•º Î∂ÑÎ¶¨
            int delimiterIndex = command.indexOf(':');
            String version = command.substring(delimiterIndex + 1);
            version.trim();
            Serial.printf("\nwrite version %s to flash\n", version.c_str());
            SetIniString("software", "version", version);
          }
          else if(command.equals("read version")){
            // Serial.println("read software version : ");
            // Serial.println(GetIniString("software", "version", "0"));
            Serial.printf("\nread version %s from flash", GetIniString("software", "version", "0").c_str());
          }

          // 2024-06-09 : Ï¶ùÎ™ÖÏÑúÎ•º Îã§Ïãú Î∞úÌñâÌïòÎäî Î™ÖÎ†π, Ï¶ùÎ™ÖÏÑúÍ∞Ä ÌïúÎ≤à ÏÑ∏ÌåÖÏù¥ ÎêòÎ©¥ Îã§ÏãúÎäî Ìï† ÌïÑÏöîÍ∞Ä ÏóÜÎã§. 
          else if (command.equals("reset_cert")) {
          
            initializeAwsJson();

            Serial.println("reset certification");
          }

          // 2024-06-09 : stm Î≥¥ÎìúÏóêÏÑú Ï∂îÍ∞Ä Íµ¨ÌòÑ, softAP resetÏù¥ Ïò§Î©¥ Ïù¥Î†áÍ≤å Ï≤òÎ¶¨Î•º ÌïòÎ©¥ ÎêúÎã§. Ï∂îÍ∞Ä Íµ¨ÌòÑ
          else if(command.equals("reset softap")){
              Serial.println("\n\n reset softAp  \n\n");
              
              SetIniString("softap", "ssid", "init_ap");
              deleteAllFiles();

              ESP.restart();
              
          }
          
          //2024-06-09 : mac addressÎ•º ÏñªÏñ¥ÎÇ∏Îã§. 
          else if(command.equals("mac_address")){
              String macAddress = WiFi.macAddress();
              char macAdd[100];
              macAddress.toCharArray(macAdd, 100);
              Serial.printf("\n\nmac address : %s \n\n", macAdd);
          }

          else if (command.equals("disconnect_mqtt")){
            Serial.println("mqtt disconnect test.. ");
            client.disconnect();
            delay(2000);
          }
          
          
          else if(command.equals("set softap")){
              Serial.println("\n\n set softAp  \n\n");
              SetIniString("softap", "ssid", "operate");
              
          }
          else if(command.equals("get softap")){

            // String getId = GetIni("softap", "ssid", "none");
            Serial.println("get softap : ");
            Serial.println(GetIniString("softap", "ssid", "none"));

          }
          else{
            Serial.println("Serial input command error!!!!!!!!");
          }
        }
  

  }
  
  
  


  // 2024-05-06 :SerialPortÎ°úÎ∂ÄÌÑ∞ Îç∞Ïù¥ÌÑ∞Î•º ÏùΩÏñ¥Ïò¥
  // OZS Î≥¥ÎìúÏóêÏÑú MQTTÍ∞Ä Ïó∞Í≤∞Ïù¥ ÎêòÏóàÎäîÏßÄ ÌôïÏù∏ Î©îÏÑ∏ÏßÄÎ•º Ï≤òÎ¶¨ÌïúÎã§. 
  // ÌôïÏù∏ Î©îÏÑ∏ÏßÄ "hello 8226"
  // 2024-06-04 : ESP32Î°ú upgradeÌï®.

  while (Serial2.available() > 0) {
     // ÏãúÎ¶¨Ïñº Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
    char incomingChar = Serial2.read();

    // '['Í∞Ä Îì§Ïñ¥Ïò§Î©¥ ÎÇ¥Î∂Ä Î¨∏ÏûêÏó¥ ÏãúÏûë
    if (incomingChar == '[') {
      insideBrackets = true;
      receivedString = ""; // ÏÉàÎ°úÏö¥ Î¨∏ÏûêÏó¥ ÏãúÏûë
    }
    // ']'Í∞Ä Îì§Ïñ¥Ïò§Î©¥ ÎÇ¥Î∂Ä Î¨∏ÏûêÏó¥ ÎÅù
    else if (incomingChar == ']') {
      insideBrackets = false;
      
      // ÎÇ¥Î∂Ä Î¨∏ÏûêÏó¥ÏùÑ Ï≤òÎ¶¨ (Ïòà: ÏãúÎ¶¨Ïñº Î™®ÎãàÌÑ∞Î°ú Ï∂úÎ†•)
      Serial.println(" Rx=" + receivedString);

      // 2024-05-06 : "8266" Î¨∏ÏûêÏó¥Ïù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏó¨ Ï≤òÎ¶¨
      if (receivedString.indexOf("8266") != -1) {
        // "8266"Ïù¥ Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏúºÎ©¥ send_wifi_ready() Ìï®Ïàò Ìò∏Ï∂ú
        send_wifi_ready();
      }
      else if(receivedString.indexOf("OZS") != -1){
        publish_ozs_status(receivedString);
      }
      else if(receivedString.indexOf("SYSINFO") != -1){
         publish_ozs_system_info(receivedString);
      }
      else{
        Serial.println("Serial2: critical error:!!!!!!");
      }


    }
    // '['ÏôÄ ']' ÏÇ¨Ïù¥Ïùò Î¨∏ÏûêÏó¥Ïù∏ Í≤ΩÏö∞ receivedStringÏóê Î¨∏Ïûê Ï∂îÍ∞Ä
    else if (insideBrackets) {
      receivedString += incomingChar;
    }
  }

  //2024-05-29 : 10ms ÎßàÎã§ ÌïúÎ≤àÏî© Ï≤¥ÌÅ¨ÌïúÎã§. ÏãúÍ∞ÑÏùÑ ÌöçÍ∏∞Ï†ÅÏúºÎ°ú Ï§ÑÏòÄÎã§.
  // delay(100);


}